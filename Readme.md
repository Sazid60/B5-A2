## How can you calculate aggregate functions like `COUNT()`, `SUM()`, and `AVG()` in PostgreSQL?

**ANS:**

### AGGREGATION কী?

একটি ডাটাবেসের ভেতরে প্রচুর তথ্য থাকে। কখনও কখনও আমাদের সমস্ত তথ্য থেকে কর্মচারীর মোট বেতনের মতো সমস্ত তথ্য ব্যবহার করে প্রক্রিয়াজাত তথ্য জানতে হয়, এখানে সাহায্যের সাথে `Aggregation` আসে। `Aggregation` আসলে লক্ষ্যযুক্ত ডেটা ক্ষেত্রের সারাংশ গণনার প্রক্রিয়া। `Aggregation` মূলত `SUM()`, `COUNT()`, `AVG()`, `MAX()` এবং `MIN()` এর মতো কিছু ফাংশন ব্যবহার করে করা হয়। `Aggregation` `GROUP BY` clause এর সাথে সবচেয়ে সামঞ্জস্যপূর্ণ। ফাংশনের নামগুলিই বলে যে এটি কী করবে।

ধরুন আমাদের কাছে একটি কোম্পানির টেবিল আছে যেখানে আমাদের নাম `আইডি`, `নাম`, `ডিপার্টমেন্ট`, `বেতন` কলাম আছে। এবার ধাপে ধাপে অ্যাগ্রিগেশন ফাংশনগুলি অন্বেষণ করা যাক।

| id  | name    | department  | salary |
| --- | ------- | ----------- | ------ |
| 1   | Alice   | HR          | 5000   |
| 2   | Bob     | Engineering | 7000   |
| 3   | Charlie | HR          | 6000   |
| 4   | David   | Engineering | 8000   |
| 5   | Eve     | Marketing   | 5500   |

### `SUM()` ফাংশনের ব্যবহার

ধরুন এইচআর ডেভেলপারকে বলছে, "ভাই, দয়া করে সাহায্য করুন! বস আমাকে অতিরিক্ত খরচের জন্য দোষারোপ করছেন। আমাদের তাকে দেখাতে হবে যে মোট বেতনের জন্য কত খরচ হচ্ছে!" ডেভেলপার SQL খোলে এবং এই কোয়েরিটি চালায়:

```sql
SELECT department,
SUM(salary) AS total_salary
FROM employees
GROUP BY department;
```

তাহলে `SUM()` কিভাবে কাজ করছে? এটি প্রতিটি সারিতে যায়, প্রতিটি কর্মচারীর বেতন সংগ্রহ করে, তারপর বিভাগ অনুসারে তাদের গ্রুপ করে, এবং তারপর প্রতিটি গ্রুপের বেতনের পরিমাণ দেখায়। সহজ, তাই না? যখন হাজার হাজার ডেটা থাকবে তখন এটি HR-এর মস্তিষ্কের চাপ কমাবে।

### `COUNT()` ফাংশনের ব্যবহার

ডেভেলপারদের অসাধারণ রিপোর্টের কারণে বেতনের কথা ভেবে শান্ত হওয়ার পর বস হঠাৎ আক্রমণাত্মকভাবে জানতে চান যে বর্তমানে প্রতিটি বিভাগে কতজন লোক কাজ করে। তিনি ভাবছেন যে কর্মী ছাঁটাইয়ের কিছু সম্ভাবনা থাকতে পারে।

ডেভেলপার বসে পড়েন এবং SQL-এ কোয়েরি লিখতে শুরু করেন:

```sql
SELECT department,
COUNT(*) AS total_employees
FROM employees
GROUP BY department;

```

COUNT(\*) ফাংশনটি GROUP BY বিভাগীয় ধারা দ্বারা গঠিত প্রতিটি গ্রুপে সারির (কর্মচারীদের) সংখ্যা গণনা করে। এটি কর্মচারীদের টেবিলের মধ্য দিয়ে যায়, বিভাগীয় কলামের উপর ভিত্তি করে ডেটা গোষ্ঠীভুক্ত করে এবং তারপর প্রতিটি বিভাগে কতজন কর্মচারী রয়েছে তা গণনা করে। ফলাফল প্রতিটি বিভাগে মোট কর্মচারীর সংখ্যা দেখায়।

### `AVG()` ফাংশনের ব্যবহার

বস তারপর একজন গোয়েন্দার মতো hr রুমে প্রবেশ করেন এবং জিজ্ঞাসা করেন, "'স্বাভাবিক' বেতন কত? আমি প্রতিটি বিভাগের গড় বেতন জানতে চাই।"

ডেভেলপার আবার হাত লুকিয়ে এই SQL কোয়েরি লিখতে শুরু করলেন:

```sql
SELECT department,
AVG(salary) AS average_salary
FROM employees
GROUP BY department;

```

এরপর কী হবে? SQL প্রতিটি বিভাগের জন্য সমস্ত বেতন যোগ করে এবং মোট বেতনকে কর্মচারীর সংখ্যা দিয়ে ভাগ করে "সাধারণ" বেতন গণনা করে।

## 8. What is the significance of the `JOIN` operation, and how does it work in PostgreSQL?

**ANS:**

ধরেন আমাদের কাছে দুইটা টেবিল আছে। একটা টেবিল হল ইউজার টেবিল আর একটা হলো অর্ডার টেবিল।

- `ইউজার টেবিল`

| id  | first_name | last_name  |
| --- | ---------- | ---------- |
| 1   | F. Scott   | Fitzgerald |
| 2   | Ernest     | NULL       |
| 3   | William    | Faulkner   |
| 4   | NULL       | Eliot      |
| 5   | John       | Steinbeck  |
| 6   | Sarah      | Connor     |

- `অর্ডার টেবিল`
  | id | user_id | number | total |
  | -- | -------- | --------- |
  | 1 | 2 | 01911.... | 32.00 |
  | 2 | 3 | 01911.... | 75.99 |
  | 3 | 1 | 01911.... | 24.99 |
  | 4 | 1 | NULL | 118.25 |
  | 5 | 5 | 01911.... | NULL |
  | 6 | 999 | 01911.... | 40.00 |
  | 7 | NULL | 01911.... | 60.00 |

অর্ডার টেবিলের ভেতরে ইউজার আইডিটা একটা ফরেন কি হিসেবে কাজ করতেছে সে ইউজার টেবিলের আইডি টা রেফার করতেছে। এখানে দেখা যায় অর্ডার টেবিল এর ভিতর যদি আমরা ইউজার এর ইনফরমেশন টা দেখতে চাই আমরা ইউজার ইনফরমেশন টা ডিরেক্টলি দেখতে পারিনা। এখানেই আসে `JOIN` এর কনসেপ্ট। আমরা দুইটা টেবিল কে জয়েন করে ইনফরমেশন একসাথে দেখতে পারি।

### `INNER JOIN` এর ব্যবহার

```sql
SELECT * FROM ORDERS
INNER JOIN  orders ON users.id = orders.user_id;
```

এখানে আসলে হচ্ছেটা কি? প্রথমে আমরা ইনার জয়েন্ট বোঝার চেষ্টা করি। এখানে আমরা চেষ্টা করতেছি অর্ডার টেবিলের মধ্যে ইউজার ইনফরমেশন গুলো দেখতে চাচ্ছি টেবিল আমরা সাথে জয়েন করতে চাচ্ছি ইনার জয়েন এর মাধ্যমে। এখানে ইনার জয়ন্ত ডিপেন্ড করতেছে ইউজার টেবিলের ইউজার আইডি আর অর্ডার টেবিলের ইউজার আইডি এর সাথে সম্পর্ক আছে কিনা `users.id = orders.user_id`। যদি এই কন্ডিশনটা মিলে যায় সে এই অর্ডার টেবিলের পাশে মিলে যাওয়া ইউজারের কলামগুলা দেখায় দিবে জয়েন করে দেবে। ইনার জয়েন্ট তখনই রেকর্ড রিটার্ন করে যখন দুইটা জয়েন কন্ডিশন মিলে যায় । যদি না থাকে তাহলে সেই রেকর্ড ইনার জয়েন রেজাল্ট আসবে না।

ইনার জয়েন এর আউটপুট আমরা দেখতে পারি এমনটা হবে:

| users.id | first_name | last_name  | orders.id | user_id | number    | total  |
| -------- | ---------- | ---------- | --------- | ------- | --------- | ------ |
| 1        | F. Scott   | Fitzgerald | 3         | 1       | 01911.... | 24.99  |
| 1        | F. Scott   | Fitzgerald | 4         | 1       | NULL      | 118.25 |
| 2        | Ernest     | NULL       | 1         | 2       | 01911.... | 32.00  |
| 3        | William    | Faulkner   | 2         | 3       | 01911.... | 75.99  |
| 5        | John       | Steinbeck  | 5         | 5       | 01911.... | NULL   |

### `LEFT JOIN` & `RIGHT JOIN` এর ব্যবহার

#### `RIGHT JOIN`

`LEFT JOIN` আসলে কি এটার নামই আমাদেরকে বলে দিচ্ছে যে এটা বাম পাশে থাকা টেবিলের সব রেকর্ড দেখায় দিবে। ধরেন আমাদের বাম পাশের টেবিলের কিছু কলাম আছে যেগুলোতে ডাটা আছে। কিন্তু আমাদের ডান পাশের টেবিলে বাম পাশে টেবিলে থাকার ওই ইনফরমেশন বা কলাম গুলোর রিলেভেন কোন ডাটা নাই। আমরা যদি এখানে আজ রেগুলার জয়েন ইউজ করি তাহলে কলাম টাই আমাদের বাদ করে দিবে বা আমাদের টেবিলে দেখাবে না। এখন আমরা লেফট জয়েন্ট করতে পারি যেন আমাদের বাম পাশের টেবিলের যতগুলা কলামের ডাটা গুলা আছে সবগুলো দেখাবে এবং ডান পাশের যে টেবিল যদি ডাটা থাকে তাহলে দেখাবে যদি না থাকে তাহলে আমাদেরকে `NULL` দেখাবে।

একটা সিনারিও আমরা চিন্তা করতে পারি যে আমরা টেবিল গুলোতে দেখতে পারছি ৬ নাম্বার ইউজার কখনো কোন কিছু অর্ডার করে নাই। সে যেহেতু কোন কিছু অর্ডার করে নাই নরমাল জয়েন করলে আমরা দেখতে পারবো যে সে আমাদের জয়েন্ট টেবিলে নাই। কিন্তু আমরা তো নাছোড়বান্দা আমরা দেখতে চাই কে সে যে কিছু অর্ডার করে নাই।

```sql
SELECT users.id AS user_id,users.first_name,users.last_name,orders.id AS order_id,orders.number,orders.total FROM users
LEFT JOIN orders ON orders.user_id = users.id;
```

এখানে আমরা ইউজার টেবিলটাকে যদি লেফটে রাখি এবং লেফট জয়েন দিয়ে আমরা কানেক্ট করি একটা কন্ডিশন দিয়ে ইউজার আইডি আর ইউজারের ইউজার আইডি সমান। তাহলে আমরা দেখতে পারবো যে টেবিলে আমাদের ইউজারের নামটা দেখা যাচ্ছে এখন এবং সে যেহেতু কোনো অর্ডার করে নাই ডান পাশে যে টেবিলটা জয়েন হবে অর্ডার টেবিলটা সেই অর্ডার টেবিলে সব ইনফরমেশন `NULL` দেখাবে ।

`LEFT JOIN` এর আউটপুট আমরা দেখতে পারি এমনটা হবে:

| users.id | first_name | last_name  | orders.id | user_id | number    | total  |
| -------- | ---------- | ---------- | --------- | ------- | --------- | ------ |
| 1        | F. Scott   | Fitzgerald | 3         | 1       | 01911.... | 24.99  |
| 1        | F. Scott   | Fitzgerald | 4         | 1       | NULL      | 118.25 |
| 2        | Ernest     | NULL       | 1         | 2       | 01911.... | 32.00  |
| 3        | William    | Faulkner   | 2         | 3       | 01911.... | 75.99  |
| 4        | NULL       | Eliot      | NULL      | NULL    | NULL      | NULL   |
| 5        | John       | Steinbeck  | 5         | 5       | 01911.... | NULL   |
| 6        | Sarah      | Connor     | NULL      | NULL    | NULL      | NULL   |

#### `RIGHT JOIN`

তো রাইট জয়েন হল লেফট জয়েন এর ঠিক উল্টা। এর মানে হলো ধরেন টেবিলে আমার ইনফরমেশন আছে বা কলামগুলা আমার ডাটা হোল্ড করতেছে কিন্তু বাম পাশে ওই ডান পাশের কলমের রিলেভেন্ট একটা ডাটা আমার নাই। তো এখন আমাদের রাইট জয়েন কি করবে সে ডান পাশের যে ডাটা গুলো অ্যাভেলেবেল আছে সে ডাটা গুলা সে দেখাবে বাম পাশের যে ডাটা গুলো আসলে নাই সেসব জায়গায় সে নাল দেখায় দিবে। আমরা চিন্তা করতে পারি কোন একটা অর্ডার প্লেস হয়ে গেছে কিন্তু সাম হাও আমার ইউজারের যে আইডিটা আছে বা ইউজারের যে ইনফরমেশন গুলো আছে সেগুলো আছে ডিলিট করে ফেলছে এটা খুঁজে বের করতে চাই তখন আমরা রাইট জয়েন ইউজ করব সে অর্ডার ইনফরমেশনটা দেখাবে আর এইটার রিলেইলেভেন্ট সে আমাদেরকে দেখায় দিবে।

```SQL
SELECT orders.id AS order_id, orders.user_id, orders.number, orders.total,users.first_name,users.last_name FROM users
RIGHT JOIN orders ON users.id = orders.user_id;
```

`RIGHT JOIN` এর আউটপুট আমরা দেখতে পারি এমনটা হবে:

| order_id | user_id | number    | total  | first_name | last_name  |
| -------- | ------- | --------- | ------ | ---------- | ---------- |
| 1        | 2       | 01911.... | 32.00  | Ernest     | NULL       |
| 2        | 3       | 01911.... | 75.99  | William    | Faulkner   |
| 3        | 1       | 01911.... | 24.99  | F. Scott   | Fitzgerald |
| 4        | 1       | NULL      | 118.25 | F. Scott   | Fitzgerald |
| 5        | 5       | 01911.... | NULL   | John       | Steinbeck  |
| 6        | 999     | 01911.... | 40.00  | NULL       | NULL       |
| 7        | NULL    | 01911.... | 60.00  | NULL       | NULL       |

## `FULL JOIN` ,`CROSS JOIN` & `NATURAL JOIN` এর ব্যবহার

#### `FULL JOIN`

আসেন আমরা এখন ফুল জয়েন টা বুঝি ফুল জয়েন হলো আপনার লেফট জয়েন আর রাইট জন দুইটা টেবিলের সব রেকর্ড দেখায় যেসব রেকর্ড ম্যাচ করবে না সেগুলোর জন্য নাল দেখাবে ।

```sql
SELECT
  users.first_name,
  orders.number
FROM users
FULL JOIN orders ON users.id = orders.user_id;
```

#### `CROSS JOIN`

তো ক্রস জইনটা কি কাজ করে ক্রাস চীন দুইটা টেবিলের কার্টেসিয়ান প্রোডাক্ট দেখায়। ধরেন যদি ইউজার টেবিলের তিনটা রেকর্ড থাকে এন্ড অর্ডার টেবিলের আউটপুট টা দেখাবে 3 × 3 = 9; মানে ইউজার টেবিলের সাথে অর্ডার টেবিলের যতগুলা কম্বিনেশন সম্ভব সবগুলো কম্বিনেশন সে দেখাবে

```SQL
SELECT
  users.first_name,
  orders.number
FROM users
CROSS JOIN orders;

```

#### `NATURAL JOIN`

ন্যাচারাল জয়েন আন্ডার দ্য হুড প্রথমে ক্রস জয়েন করে। ক্রস জয়েন করার পরে সে দেখে যে আপনার যে টার্গেটেড কলাম দুইটা দিয়ে আমরা জয়েন করতে চাচ্ছি দুইটার ভ্যালু যে সব জায়গায় সমান পাবে সেসব জায়গায় সেসব ফিল্ড গুলোকে সে আসলে দেখায় দিবেকিন্তু এ ক্ষেত্রে খেয়াল রাখতে হবে যে যেসব ফিল্ডে কমপেয়ার করতেছি ঐসব ফিল্ডের কলাম নেমটা সেইম হইতে হবে

```SQL
SELECT *
FROM users
NATURAL JOIN orders;
```

সবশেষে বলা যায় যখন আমরা মাল্টিপল টেবিল নিয়ে কাজ করি এবং একটা টেবিলের মধ্যে অন্য টেবিলের ইনফরমেশন গুলো আমরা দেখতে চাই বা এক্সেস করতে চাই তখন জয়েন আমাদেরকে বিভিন্নভাবে সাহায্য করে

1. Explain the `GROUP BY` clause and its role in aggregation operations.

2. What is the difference between the `VARCHAR` and `CHAR` data types?

3. Explain the purpose of the `WHERE` clause in a `SELECT` statement.
