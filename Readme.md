## 10. How can you calculate aggregate functions like `COUNT()`, `SUM()`, and `AVG()` in PostgreSQL?

**ANS:**

### AGGREGATION কী?

একটি ডাটাবেসের ভেতরে প্রচুর তথ্য থাকে। কখনও কখনও আমাদের সমস্ত তথ্য থেকে কর্মচারীর মোট বেতনের মতো সমস্ত তথ্য ব্যবহার করে প্রক্রিয়াজাত তথ্য জানতে হয়, এখানে সাহায্যের সাথে `Aggregation` আসে। `Aggregation` আসলে লক্ষ্যযুক্ত ডেটা ক্ষেত্রের সারাংশ গণনার প্রক্রিয়া। `Aggregation` মূলত `SUM()`, `COUNT()`, `AVG()`, `MAX()` এবং `MIN()` এর মতো কিছু ফাংশন ব্যবহার করে করা হয়। `Aggregation` `GROUP BY` clause এর সাথে সবচেয়ে সামঞ্জস্যপূর্ণ। ফাংশনের নামগুলিই বলে যে এটি কী করবে।

ধরুন আমাদের কাছে একটি কোম্পানির টেবিল আছে যেখানে আমাদের নাম `আইডি`, `নাম`, `ডিপার্টমেন্ট`, `বেতন` কলাম আছে। এবার ধাপে ধাপে অ্যাগ্রিগেশন ফাংশনগুলি অন্বেষণ করা যাক।

| id  | name    | department  | salary |
| --- | ------- | ----------- | ------ |
| 1   | Alice   | HR          | 5000   |
| 2   | Bob     | Engineering | 7000   |
| 3   | Charlie | HR          | 6000   |
| 4   | David   | Engineering | 8000   |
| 5   | Eve     | Marketing   | 5500   |

### `SUM()` ফাংশনের ব্যবহার

ধরুন এইচআর ডেভেলপারকে বলছে, "ভাই, দয়া করে সাহায্য করুন! বস আমাকে অতিরিক্ত খরচের জন্য দোষারোপ করছেন। আমাদের তাকে দেখাতে হবে যে মোট বেতনের জন্য কত খরচ হচ্ছে!" ডেভেলপার SQL খোলে এবং এই কোয়েরিটি চালায়:

```sql
SELECT department,
SUM(salary) AS total_salary
FROM employees
GROUP BY department;
```

তাহলে `SUM()` কিভাবে কাজ করছে? এটি প্রতিটি সারিতে যায়, প্রতিটি কর্মচারীর বেতন সংগ্রহ করে, তারপর বিভাগ অনুসারে তাদের গ্রুপ করে, এবং তারপর প্রতিটি গ্রুপের বেতনের পরিমাণ দেখায়। সহজ, তাই না? যখন হাজার হাজার ডেটা থাকবে তখন এটি HR-এর মস্তিষ্কের চাপ কমাবে।

### `COUNT()` ফাংশনের ব্যবহার

ডেভেলপারদের অসাধারণ রিপোর্টের কারণে বেতনের কথা ভেবে শান্ত হওয়ার পর বস হঠাৎ আক্রমণাত্মকভাবে জানতে চান যে বর্তমানে প্রতিটি বিভাগে কতজন লোক কাজ করে। তিনি ভাবছেন যে কর্মী ছাঁটাইয়ের কিছু সম্ভাবনা থাকতে পারে।

ডেভেলপার বসে পড়েন এবং SQL-এ কোয়েরি লিখতে শুরু করেন:

```sql
SELECT department,
COUNT(*) AS total_employees
FROM employees
GROUP BY department;

```

COUNT(\*) ফাংশনটি GROUP BY বিভাগীয় ধারা দ্বারা গঠিত প্রতিটি গ্রুপে সারির (কর্মচারীদের) সংখ্যা গণনা করে। এটি কর্মচারীদের টেবিলের মধ্য দিয়ে যায়, বিভাগীয় কলামের উপর ভিত্তি করে ডেটা গোষ্ঠীভুক্ত করে এবং তারপর প্রতিটি বিভাগে কতজন কর্মচারী রয়েছে তা গণনা করে। ফলাফল প্রতিটি বিভাগে মোট কর্মচারীর সংখ্যা দেখায়।

### `AVG()` ফাংশনের ব্যবহার

বস তারপর একজন গোয়েন্দার মতো hr রুমে প্রবেশ করেন এবং জিজ্ঞাসা করেন, "'স্বাভাবিক' বেতন কত? আমি প্রতিটি বিভাগের গড় বেতন জানতে চাই।"

ডেভেলপার আবার হাত লুকিয়ে এই SQL কোয়েরি লিখতে শুরু করলেন:

```sql
SELECT department,
AVG(salary) AS average_salary
FROM employees
GROUP BY department;

```

এরপর কী হবে? SQL প্রতিটি বিভাগের জন্য সমস্ত বেতন যোগ করে এবং মোট বেতনকে কর্মচারীর সংখ্যা দিয়ে ভাগ করে "সাধারণ" বেতন গণনা করে।

## 4. What is the difference between the `VARCHAR` and `CHAR` data types?

**ANS:**

#### ডাটা টাইপ কি?

ডাটা টাইপ বলতে আমরা এখানে বোঝাচ্ছি যে আমরা যে ডাটা গুলো আমরা রাখতেছি ডাটাবেজে এগুলা আসলে কি ধরনের ডাটা। আমরা সাধারণত টেবিল ক্রিয়েশনের সময় কোন কলামের ডাটা টাইপ টা কি হবে। তবে একটা কলামের জন্য একটা ফিক্সড ডাটা টাইপ থাকতে হয়। ফিক্সড ডাটা টাইপ রাখলে কনসিসটেন্সি বাড়ে, কার্তেশিয়ান ইনফোর্সমেন্ট ভ্যালিডেশন হয়, কনভেনিয়েন্স এন্ড ফাঙ্কশনালিটি ভালো হয় এবং স্টোরেজ ইফিশিয়েন্সি বাড়ে। বিভিন্ন ধরনের ডাটা টাইপ আসলে আমরা দেখতে পারি পোস্টগ্রেস এ।

1. Data Type in Postgres
2. Boolean
3. Number
4. Binary
5. Date/Time
6. Json
7. Character
8. UUID
9. Array
10. XML

এসব ডাটা টাইপের মধ্যে বেশিরভাগ সময় আমরা বুলিয়ান, নাম্বার, ডেট এন্ড টাইম, ক্যারেক্টার এবং ইউ ইউ আইডি ব্যবহার করি। আসেন এখন আমরা ক্যারেক্টার ডাটা টাইপ নিয়ে কিছু কথা বলি। আসলে তিন ধরনের ক্যারেক্টার ডাটা টাইপ আছে `CHAR()`, `VARCHAR()` এন্ড `TEXT` । তবে আমরা বুঝার চেষ্টা করব `CHAR()`এবং `VARCHAR()` মধ্যে পার্থক্যটা কি

#### `CHAR()` এবং `VARCHAR()` ডাটা টাইপের মধ্যে পার্থক্য 

`CHAR()` হল একটা নির্দিষ্ট দৈর্ঘ্যের ক্যারেক্টার টাইপ । ইনপুট স্ট্রিং কখনো ওই নির্দিষ্ট দৈর্ঘ্যের চেয়ে বড় হতে পারবেনা। যদি নির্দিষ্ট দৈর্ঘ্যের থেকে ছোট হয় তাহলে পেস দিয়ে স্পেস করে ফেলে।

```sql
name CHAR(10)
```

উদাহরণটা দেখেন। এটা সবসময় ক্যারেক্টারের জায়গা ধরে রাখবে। যদি দশটি ক্যারেক্টার এর থেকে কম হয় তাহলে সে ফাঁকা জায়গা কে স্পেস দিয়ে পূরণ করবে।
যদি কেউ "Alif" লেখে, তাহলে ডাটাবেজে সেটি "Alif " (ছয় টি স্পেসসহ) হিসাবে সেভ হবে।

স্পেস থাকাটা মোটেও ঠিক না । আমরা যদি চাই অবাঞ্ছিত কোন থান চাইনা ডাটার মধ্যে, তাহলে আমরা `VARCHAR()` ইউজ করতে পারি ।

`VARCHAR()` এ আসলে দৈর্ঘ্যে নির্দিষ্ট করা হয় ঠিক `CHAR()`মতই কিন্তু নির্দিষ্ট দৈর্ঘ্যের চেয়ে কম দৈর্ঘ্যের ডাটা যদি আমরা ইনপুট দেই তাহলে সে ফাঁকা স্পেস দিয়ে প্যাডিং করবে না। এটা স্টোরেজের দিক থেকে অনেকটা বেশি কার্যকর কারণ এটা বেশি জায়গা অপচয় হতে দেয় না।

```sql
name VARCHAR(100)
```

ধরেন আমরা দিলাম `name VARCHAR(100)`। ইনপুট টা ম্যাক্সিমাম ১০০ ক্যারেক্টার হতে পারবে অথবা এর থেকে নিচেও হতে পারবে । যদি কেউ "Alif" লেখে, তাহলে ডাটাবেজে সেটি "Alif" হিসাবেই সেভ হবে।

## 6. What are the LIMIT and OFFSET clauses used for?

**ANS:**

মনে করেন একটা ওয়েবসাইটে হাজার হাজার ডাটা আছে ৷ আসলে হাজার হাজার ডাটা কে একেবারে একটা পেইজে দেখতে পারবো না অথবা একেবারে লোড করে দেখাতে পারবো না। সাধারণত ডাটা গুলোকে পেজি নেশন এর মাধ্যমে দেখানো হয়। এখানে পেজিনেশন করতে লিমিট আর অফসেট ব্যবহার করা হয় ৷ এছাড়াও লিমিট ইউজ করে আমরা নির্দিষ্ট সংখ্যক ডাটা ধরে আনতে পারি। তাহলে অফসেট আসলে ইউজ হয় কতগুলো ডাটা আসলে আমরা বাদ দিয়ে করে ডাটা দেখাবো এই কাজটা করার জন্য।

আসেন এখন আমরা লিমিট এবং অফসেটের ব্যবহারগুলো দেখি বিভিন্ন ক্ষেত্রে

- মনে করেন আমাদের অনেক ডাটা আছে কিন্তু এই ডাটা গুলোর মধ্যে আমরা দেখতে চাই শুধুমাত্র তিনটা ডাটা । আমরা লিমিট ব্যবহার করে শুধুমাত্র তিনটা ডাটা দেখতে পারি.

```sql
SELECT * FROM books LIMIT 3;
```

- আমরা একটা দোকানের অনেকগুলো আমরা অনেকগুলো ল্যাপটপের মধ্যে সবথেকে দামি ল্যাপটপটা দেখতে চাই। আমরা প্রথমে প্রাইস ব্যবহার করে ডিসেন্ডিং অর্ডার করবো পরবর্তীতে আমরা এটাকে একটা লিমিট করে দেব।

```sql
SELECT * FROM laptops
ORDER BY price DESC
LIMIT 1;
```

- আমরা যদি এখন দেখতে চাই সবচেয়ে দামি ল্যাপটপ বাদ দিয়ে এর নিচে তিনটা দামি ল্যাপটপ কি কি আছে, এক্ষেত্রে আমরা অফসেট ব্যবহার করতে পারি । এখানে প্রথমে দাম অনুযায়ী সবথেকে দামি ল্যাপটপ ল্যাপটপটা আগে আসবে পরবর্তীতে আমরা অফসেট বলে দিব এক। এর মানে সবথেকে দামি ল্যাপটপ একটা বাদ দাও। পরবর্তীতে আমরা লিমিট করে দিব তিন। এর মানে সব থেকে দামি ল্যাপটপ টা বাদ দেওয়ার পরবর্তী তিনটা দামি ল্যাপটপ আমাকে দেখাও ।

```sql
SELECT * FROM laptops
ORDER BY price DESC
LIMIT 3 OFFSET 1;
```

- অফসেট এবং লিমিট বহুলভাবে ব্যবহৃত হয় পেজিনেশন এর ক্ষেত্রে । একটা সিনারিও আমরা যদি আলোচনা করতে পারি যে আমাদের ডাটা আছে `৩০` টা  আমরা পেইজ রাখবো `তিনটা` এবং আমরা ডাটা দেখাবো `দশটা` করে তাহলে দেখি যে আপনার অফসেট ব্যবহার করে কিভাবে পেইজিনেশন করতে পারি ।

```sql
-- page-1
SELECT * FROM products
LIMIT 10 OFFSET 0;

-- page-2

SELECT * FROM products
LIMIT 10 OFFSET 10;

-- page3

SELECT * FROM products
LIMIT 10 OFFSET 20;

```

- অফসেট বের করার জন্য আমরা এই ফর্মুলাটা ইউজ করতে পারি

```sql
OFFSET = (page number - 1) * items per page
LIMIT  = items per page
```

এখানে প্রথম পেজে দশটা ডাটা দেখানো হয়েছে এবং অফসেট রাখা হয়েছে ০ । পরবর্তী পেইজে লিমিট রাখা হয়েছে ১০ এবং অফসেট রাখা হয়েছে ১০ এর মানে হইল সে দশটা দাতা দেখাবে অফসেট দশের মাধ্যমে প্রথম ১০ ডাটা বাদ দিয়ে পরের দশটা ডাটা সে দেখাবে । এখানে তিন নাম্বার পেইজে দেখানো হয়েছে লিমিট ১০ এবং অফসেট ২০। তো তিন নাম্বার পেইজে সে ডাটা দেখাচ্ছে ১০ টা কিন্তু সে প্রথমে কিন্তু সে প্রথম ২০ ডাটা বাদ দিয়ে পরবর্তী ১০ ডাটা  দেখাবে ।

আমরা এই ভাবেই লিমিট আর অফসেটকে ব্যবহার করতে পারি ।

## 5. Explain the purpose of the WHERE clause in a SELECT statement.

**ANS:**

#### `WHERE` Clause আসলে কি?

এটিই হলো SQL এর ডাটা ফিল্টার করে আনার একটা গুরুত্বপূর্ণ মাধ্যম। আমরা এর সাহায্যে শুধুমাত্র যে ডাটাগুলা বা যেই ডাটা টি আমরা চাই ডাটাবেজ থেকে তুলে আনতে পারি।
এরমধ্যে বিভিন্ন ধরনের কন্ডিশন দেওয়া যায় । আসেন আমরা `WHERE` নিয়ে একটু খেলাধুলা করি ।

আমরা `WHERE` ক্লজ এর কিছু উদাহরণ দেখি।

1. নির্দিষ্ট রো সিলেক্ট করা
   ```sql
   WHERE id = 1
   ```
2. কোনো একটি নির্দিষ্ট মানের উপর ভিত্তি করে ফিল্টার
   ```sql
   WHERE status = 'active'
   ```
3. মাল্টিপল শর্তে ফিল্টার করা
   ```sql
   WHERE age > 18 AND city = 'Dhaka'
   ```
4. রেঞ্জের মধ্যে ডেটা সিলেক্ট করা
   ```sql
   WHERE salary BETWEEN 30000 AND 60000
   ```
5. একাধিক মানের মধ্যে যেকোনো একটি মিললে
   ```sql
   WHERE role IN ('admin', 'editor', 'manager')
   ```
6. একটি নির্দিষ্ট কলামে মান নেই
   ```sql
   WHERE deleted_at IS NULL
   ```
7. LIKE দিয়ে আংশিক ম্যাচ করা
   ```sql
   WHERE name LIKE '%SAZID%'
   ```
8. NOT দিয়ে মান বাদ দেওয়া
   ```sql
   WHERE department != 'HR'
   ```
9. IS NOT NULL ব্যবহার করে যেসব ডেটা পূর্ণ
   ```sql
   WHERE email IS NOT NULL
   ```
10. DATE এর উপর ফিল্টার
    ```sql
    WHERE created_at < CURRUENT_DATE()
    ```
11. সাবকোয়্যারি ব্যবহার করে কন্ডিশন চেক

```SQL
WHERE user_id IN (SELECT id FROM users WHERE is_active = 1)
```

এসব কিছু উদাহরণ। এছাড়াও আমরা বিভিন্নভাবে একে ইউজ করতে পারি। সর্বোপরি বলা যায় where ক্লজের গুরুত্ব অপরিসীম।

আমরা whire ক্লোজ এর ভিতরে অনেক জটিল কুয়েরি লিখতে পারি যেটা অনেক জটিল জটিল কম্বিনেশন থেকে আমাদের কাঙ্খিত ডাটা ধরে আনতে সাহায্য করে । বাস্তবিক জীবনে এটি ব্যবহার করা হয় সার্চিং এবং ফিল্টারিং এ, ইনভেন্টরি ম্যানেজমেন্ট করার জন্য, রিপোর্টিং এর জন্য প্রমোশনের জন্য ইউজার কাস্টমাইজেশন এর জন্য ।

## 8. What is the significance of the `JOIN` operation, and how does it work in PostgreSQL?

**ANS:**

ধরেন আমাদের কাছে দুইটা টেবিল আছে। একটা টেবিল হল ইউজার টেবিল আর একটা হলো অর্ডার টেবিল।

- `ইউজার টেবিল`

| id  | first_name | last_name  |
| --- | ---------- | ---------- |
| 1   | F. Scott   | Fitzgerald |
| 2   | Ernest     | NULL       |
| 3   | William    | Faulkner   |
| 4   | NULL       | Eliot      |
| 5   | John       | Steinbeck  |
| 6   | Sarah      | Connor     |

- `অর্ডার টেবিল`

| id  | user_id | number    | total  |
| --- | ------- | --------- | ------ |
| 1   | 2       | 01911.... | 32.00  |
| 2   | 3       | 01911.... | 75.99  |
| 3   | 1       | 01911.... | 24.99  |
| 4   | 1       | NULL      | 118.25 |
| 5   | 5       | 01911.... | NULL   |
| 6   | 999     | 01911.... | 40.00  |
| 7   | NULL    | 01911.... | 60.00  |

অর্ডার টেবিলের ভেতরে ইউজার আইডিটা একটা ফরেন কি হিসেবে কাজ করতেছে সে ইউজার টেবিলের আইডি টা রেফার করতেছে। এখানে দেখা যায় অর্ডার টেবিল এর ভিতর যদি আমরা ইউজার এর ইনফরমেশন টা দেখতে চাই আমরা ইউজার ইনফরমেশন টা ডিরেক্টলি দেখতে পারিনা। এখানেই আসে `JOIN` এর কনসেপ্ট। আমরা দুইটা টেবিল কে জয়েন করে ইনফরমেশন একসাথে দেখতে পারি।

### `INNER JOIN` এর ব্যবহার

```sql
SELECT * FROM ORDERS
INNER JOIN  orders ON users.id = orders.user_id;
```

এখানে আসলে হচ্ছেটা কি? প্রথমে আমরা ইনার জয়েন্ট বোঝার চেষ্টা করি। এখানে আমরা চেষ্টা করতেছি অর্ডার টেবিলের মধ্যে ইউজার ইনফরমেশন গুলো দেখতে চাচ্ছি টেবিল আমরা সাথে জয়েন করতে চাচ্ছি ইনার জয়েন এর মাধ্যমে। এখানে ইনার জয়ন্ত ডিপেন্ড করতেছে ইউজার টেবিলের ইউজার আইডি আর অর্ডার টেবিলের ইউজার আইডি এর সাথে সম্পর্ক আছে কিনা `users.id = orders.user_id`। যদি এই কন্ডিশনটা মিলে যায় সে এই অর্ডার টেবিলের পাশে মিলে যাওয়া ইউজারের কলামগুলা দেখায় দিবে জয়েন করে দেবে। ইনার জয়েন্ট তখনই রেকর্ড রিটার্ন করে যখন দুইটা জয়েন কন্ডিশন মিলে যায় । যদি না থাকে তাহলে সেই রেকর্ড ইনার জয়েন রেজাল্ট আসবে না।

ইনার জয়েন এর আউটপুট আমরা দেখতে পারি এমনটা হবে:

| users.id | first_name | last_name  | orders.id | user_id | number    | total  |
| -------- | ---------- | ---------- | --------- | ------- | --------- | ------ |
| 1        | F. Scott   | Fitzgerald | 3         | 1       | 01911.... | 24.99  |
| 1        | F. Scott   | Fitzgerald | 4         | 1       | NULL      | 118.25 |
| 2        | Ernest     | NULL       | 1         | 2       | 01911.... | 32.00  |
| 3        | William    | Faulkner   | 2         | 3       | 01911.... | 75.99  |
| 5        | John       | Steinbeck  | 5         | 5       | 01911.... | NULL   |

#### `LEFT JOIN` & `RIGHT JOIN` এর ব্যবহার

#### `RIGHT JOIN`

`LEFT JOIN` আসলে কি এটার নামই আমাদেরকে বলে দিচ্ছে যে এটা বাম পাশে থাকা টেবিলের সব রেকর্ড দেখায় দিবে। ধরেন আমাদের বাম পাশের টেবিলের কিছু কলাম আছে যেগুলোতে ডাটা আছে। কিন্তু আমাদের ডান পাশের টেবিলে বাম পাশে টেবিলে থাকার ওই ইনফরমেশন বা কলাম গুলোর রিলেভেন কোন ডাটা নাই। আমরা যদি এখানে আজ রেগুলার জয়েন ইউজ করি তাহলে কলাম টাই আমাদের বাদ করে দিবে বা আমাদের টেবিলে দেখাবে না। এখন আমরা লেফট জয়েন্ট করতে পারি যেন আমাদের বাম পাশের টেবিলের যতগুলা কলামের ডাটা গুলা আছে সবগুলো দেখাবে এবং ডান পাশের যে টেবিল যদি ডাটা থাকে তাহলে দেখাবে যদি না থাকে তাহলে আমাদেরকে `NULL` দেখাবে।

একটা সিনারিও আমরা চিন্তা করতে পারি যে আমরা টেবিল গুলোতে দেখতে পারছি ৬ নাম্বার ইউজার কখনো কোন কিছু অর্ডার করে নাই। সে যেহেতু কোন কিছু অর্ডার করে নাই নরমাল জয়েন করলে আমরা দেখতে পারবো যে সে আমাদের জয়েন্ট টেবিলে নাই। কিন্তু আমরা তো নাছোড়বান্দা আমরা দেখতে চাই কে সে যে কিছু অর্ডার করে নাই।

```sql
SELECT users.id
AS
user_id,
users.first_name,
users.last_name,
orders.id AS order_id,
orders.number,
orders.total
FROM users
LEFT JOIN orders ON orders.user_id = users.id;
```

এখানে আমরা ইউজার টেবিলটাকে যদি লেফটে রাখি এবং লেফট জয়েন দিয়ে আমরা কানেক্ট করি একটা কন্ডিশন দিয়ে ইউজার আইডি আর ইউজারের ইউজার আইডি সমান। তাহলে আমরা দেখতে পারবো যে টেবিলে আমাদের ইউজারের নামটা দেখা যাচ্ছে এখন এবং সে যেহেতু কোনো অর্ডার করে নাই ডান পাশে যে টেবিলটা জয়েন হবে অর্ডার টেবিলটা সেই অর্ডার টেবিলে সব ইনফরমেশন `NULL` দেখাবে ।

`LEFT JOIN` এর আউটপুট আমরা দেখতে পারি এমনটা হবে:

| users.id | first_name | last_name  | orders.id | user_id | number    | total  |
| -------- | ---------- | ---------- | --------- | ------- | --------- | ------ |
| 1        | F. Scott   | Fitzgerald | 3         | 1       | 01911.... | 24.99  |
| 1        | F. Scott   | Fitzgerald | 4         | 1       | NULL      | 118.25 |
| 2        | Ernest     | NULL       | 1         | 2       | 01911.... | 32.00  |
| 3        | William    | Faulkner   | 2         | 3       | 01911.... | 75.99  |
| 4        | NULL       | Eliot      | NULL      | NULL    | NULL      | NULL   |
| 5        | John       | Steinbeck  | 5         | 5       | 01911.... | NULL   |
| 6        | Sarah      | Connor     | NULL      | NULL    | NULL      | NULL   |

#### `RIGHT JOIN`

তো রাইট জয়েন হল লেফট জয়েন এর ঠিক উল্টা। এর মানে হলো ধরেন টেবিলে আমার ইনফরমেশন আছে বা কলামগুলা আমার ডাটা হোল্ড করতেছে কিন্তু বাম পাশে ওই ডান পাশের কলমের রিলেভেন্ট একটা ডাটা আমার নাই। তো এখন আমাদের রাইট জয়েন কি করবে সে ডান পাশের যে ডাটা গুলো অ্যাভেলেবেল আছে সে ডাটা গুলা সে দেখাবে বাম পাশের যে ডাটা গুলো আসলে নাই সেসব জায়গায় সে নাল দেখায় দিবে। আমরা চিন্তা করতে পারি কোন একটা অর্ডার প্লেস হয়ে গেছে কিন্তু সাম হাও আমার ইউজারের যে আইডিটা আছে বা ইউজারের যে ইনফরমেশন গুলো আছে সেগুলো আছে ডিলিট করে ফেলছে এটা খুঁজে বের করতে চাই তখন আমরা রাইট জয়েন ইউজ করব সে অর্ডার ইনফরমেশনটা দেখাবে আর এইটার রিলেইলেভেন্ট সে আমাদেরকে দেখায় দিবে।

```SQL
SELECT orders.id
AS
order_id,
orders.user_id,
orders.number,
orders.total,users.first_name,
users.last_name
FROM users
RIGHT JOIN orders ON users.id = orders.user_id;
```

`RIGHT JOIN` এর আউটপুট আমরা দেখতে পারি এমনটা হবে:

| order_id | user_id | number    | total  | first_name | last_name  |
| -------- | ------- | --------- | ------ | ---------- | ---------- |
| 1        | 2       | 01911.... | 32.00  | Ernest     | NULL       |
| 2        | 3       | 01911.... | 75.99  | William    | Faulkner   |
| 3        | 1       | 01911.... | 24.99  | F. Scott   | Fitzgerald |
| 4        | 1       | NULL      | 118.25 | F. Scott   | Fitzgerald |
| 5        | 5       | 01911.... | NULL   | John       | Steinbeck  |
| 6        | 999     | 01911.... | 40.00  | NULL       | NULL       |
| 7        | NULL    | 01911.... | 60.00  | NULL       | NULL       |

#### `FULL JOIN` ,`CROSS JOIN` & `NATURAL JOIN` এর ব্যবহার

#### `FULL JOIN`

আসেন আমরা এখন ফুল জয়েন টা বুঝি ফুল জয়েন হলো আপনার লেফট জয়েন আর রাইট জন দুইটা টেবিলের সব রেকর্ড দেখায় যেসব রেকর্ড ম্যাচ করবে না সেগুলোর জন্য নাল দেখাবে ।

```sql
SELECT
  users.first_name,
  orders.number
FROM users
FULL JOIN orders ON users.id = orders.user_id;
```

#### `CROSS JOIN`

তো ক্রস জইনটা কি কাজ করে ক্রাস চীন দুইটা টেবিলের কার্টেসিয়ান প্রোডাক্ট দেখায়। ধরেন যদি ইউজার টেবিলের তিনটা রেকর্ড থাকে এন্ড অর্ডার টেবিলের আউটপুট টা দেখাবে 3 × 3 = 9; মানে ইউজার টেবিলের সাথে অর্ডার টেবিলের যতগুলা কম্বিনেশন সম্ভব সবগুলো কম্বিনেশন সে দেখাবে

```SQL
SELECT
  users.first_name,
  orders.number
FROM users
CROSS JOIN orders;

```

#### `NATURAL JOIN`

ন্যাচারাল জয়েন আন্ডার দ্য হুড প্রথমে ক্রস জয়েন করে। ক্রস জয়েন করার পরে সে দেখে যে আপনার যে টার্গেটেড কলাম দুইটা দিয়ে আমরা জয়েন করতে চাচ্ছি দুইটার ভ্যালু যে সব জায়গায় সমান পাবে সেসব জায়গায় সেসব ফিল্ড গুলোকে সে আসলে দেখায় দিবেকিন্তু এ ক্ষেত্রে খেয়াল রাখতে হবে যে যেসব ফিল্ডে কমপেয়ার করতেছি ঐসব ফিল্ডের কলাম নেমটা সেইম হইতে হবে

```SQL
SELECT *
FROM users
NATURAL JOIN orders;
```

সবশেষে বলা যায় যখন আমরা মাল্টিপল টেবিল নিয়ে কাজ করি এবং একটা টেবিলের মধ্যে অন্য টেবিলের ইনফরমেশন গুলো আমরা দেখতে চাই বা এক্সেস করতে চাই তখন জয়েন আমাদেরকে বিভিন্নভাবে সাহায্য করে
